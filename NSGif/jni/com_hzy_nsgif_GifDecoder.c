/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_hzy_nsgif_GifDecoder */
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <android/bitmap.h>
#include "JniWrapper.h"
#include "nsgif/libnsgif.h"

#ifndef _Included_com_hzy_nsgif_GifDecoder
#define _Included_com_hzy_nsgif_GifDecoder
#ifdef __cplusplus
extern "C" {
#endif

#define FUNC(f) Java_com_hzy_nsgif_GifDecoder_##f

void *bitmap_create(int width, int height) {
	return calloc(width * height, 4);
}

void bitmap_set_opaque(void *bitmap, bool opaque) {
	(void) opaque; /* unused */
}

bool bitmap_test_opaque(void *bitmap) {
	return false;
}

unsigned char *bitmap_get_buffer(void *bitmap) {
	return bitmap;
}

void bitmap_destroy(void *bitmap) {
	free(bitmap);
}

void bitmap_modified(void *bitmap) {
	return;
}

gif_bitmap_callback_vt bitmap_callbacks = {
	bitmap_create,
	bitmap_destroy,
	bitmap_get_buffer,
	bitmap_set_opaque,
	bitmap_test_opaque,
	bitmap_modified
};

void showError(const char *context, gif_result code) {
	switch (code) {
	case GIF_INSUFFICIENT_FRAME_DATA:
		LOGE("%s failed: GIF_INSUFFICIENT_FRAME_DATA", context);
		break;
	case GIF_FRAME_DATA_ERROR:
		LOGE("%s failed: GIF_FRAME_DATA_ERROR", context);
		break;
	case GIF_INSUFFICIENT_DATA:
		LOGE("%s failed: GIF_INSUFFICIENT_DATA", context);
		break;
	case GIF_DATA_ERROR:
		LOGE("%s failed: GIF_DATA_ERROR", context);
		break;
	case GIF_INSUFFICIENT_MEMORY:
		LOGE("%s failed: GIF_INSUFFICIENT_MEMORY", context);
		break;
	default:
		LOGE("%s failed: unknown code %i", context, code);
		break;
	}
}

int get_frame(gif_animation* gif, int index) {
	gif_result code;
	if (gif == NULL) {
		LOGE("gif is null");
		return -1;
	}
	if (index < 0 || index >= gif->frame_count) {
		LOGE("index error");
		return -1;
	}
	code = gif_decode_frame(gif, index);
	if (code != GIF_OK) {
		showError("gif_decode_frame", code);
		return -1;
	}
	return gif->frames[index].frame_delay;
}

unsigned char* load_file(const char *path, size_t* file_size);

int decode_file(const char* filePath, int* params) {
	int ret = 0;
	gif_result code;
	size_t gif_size = 0;
	unsigned char* gif_data = NULL;

	//malloc gif space
	gif_animation* gif = (gif_animation*) malloc(sizeof(gif_animation));
	if (gif == NULL) {
		LOGE("Unable to allocate gif_animation");
		return -1;
	}
	/* create our gif animation */
	gif_create(gif, &bitmap_callbacks);
	/* load file into memory */
	gif_data = load_file(filePath, &gif_size);
	if (gif_data == NULL) {
		free(gif);
		LOGE("gif_data read failed");
		return -1;
	}
	/* begin decoding */
	do {
		code = gif_initialise(gif, gif_size, gif_data);
		if (code != GIF_OK && code != GIF_WORKING) {
			showError("gif_initialise", code);
			return -1;
		}
	} while (code != GIF_OK);
	params[0] = gif->frame_count;
	params[1] = gif->width;
	params[2] = gif->height;
	params[3] = (int) gif;
	return 0;
}

/**
 * load gif file to buffer
 */
unsigned char* load_file(const char *path, size_t* file_size) {
	FILE *fd;
	struct stat sb;
	long long size;
	unsigned char* data = NULL;
	size_t n;

	fd = fopen(path, "rb");
	if (!fd) {
		LOGE("File open error[%s]", path);
		return NULL;
	}
	if (stat(path, &sb)) {
		fclose(fd);
		LOGE("File size error[%s]", path);
		return NULL;
	}
	size = sb.st_size;
	data = malloc(size);
	if (data == NULL) {
		LOGE("Unable to allocate [%lld] bytes", (long long) size);
		fclose(fd);
		return NULL;
	}
	n = fread(data, 1, size, fd);
	fclose(fd);
	if (n != size) {
		LOGE("Read to buffer from [%s] error", path);
		free(data);
		return NULL;
	}
	*file_size = size;
	return data;
}

/*
 * Class:     com_hzy_nsgif_GifDecoder
 * Method:    nInitParams
 * Signature: (Ljava/lang/String;[I)I
 */JNIEXPORT jint JNICALL FUNC(nInitParams)(JNIEnv *env, jobject thiz, jstring filePath, jintArray params) {
	int ret = 0;
	char* cfilePath = (char*) (*env)->GetStringUTFChars(env, filePath, NULL);
	int* cParams = (*env)->GetIntArrayElements(env, params, NULL);
	ret = decode_file(cfilePath, cParams);
	(*env)->ReleaseIntArrayElements(env, params, cParams, 0);
	(*env)->ReleaseStringUTFChars(env, filePath, cfilePath);
	return ret;
}

/*
 * Class:     com_hzy_nsgif_GifDecoder
 * Method:    nGetFrameBitmap
 * Signature: (ILjava/lang/Object;)I
 */JNIEXPORT jint JNICALL FUNC(nGetFrameBitmap)(JNIEnv *env, jobject thiz, jint index, jobject jbitmap, jint handler) {
	int ret = 0;
	int delay = 0;
	void* bmpAddr = NULL;
	gif_animation* gif = NULL;
	int buf_size = 0;

	gif = (gif_animation*) handler;
	if(gif == NULL){
		return -1;
		LOGE("gif is null");
	}
	buf_size = gif->width * gif->height * 4;
	delay = get_frame(gif, index);
	if (delay <= 0) {
		return -1;
	}
	if ((ret = AndroidBitmap_lockPixels(env, jbitmap, &bmpAddr)) < 0) {
		LOGE("AndroidBitmap_lockPixels() failed ! error=%d", ret);
		return ret;
	}
	memcpy(bmpAddr, gif->frame_image, buf_size);
	AndroidBitmap_unlockPixels(env, jbitmap);
	return delay * 10;
}

/*
 * Class:     com_hzy_nsgif_GifDecoder
 * Method:    nDestory
 * Signature: ()I
 */JNIEXPORT jint JNICALL FUNC(nDestory)(JNIEnv *env, jobject thiz, jint handler) {
	gif_animation* gif = (gif_animation*) handler;
	if (gif == NULL) {
		return -1;
		LOGE("gif is null");
	} else {
		free(gif->gif_data);
		gif_finalise(gif);
		free(gif);
	}
	return 0;
}

#ifdef __cplusplus
}
#endif
#endif
